"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Shadow = exports.R = void 0;
const react_1 = __importStar(require("react"));
const react_native_1 = require("react-native");
const react_native_svg_1 = require("react-native-svg");
const polished_1 = require("polished"); // To extract alpha
const utils_1 = require("./utils");
const isWeb = react_native_1.Platform.OS === 'web';
/** Rounds the given size to a pixel perfect size. */
function R(value) {
    // In Web, 1dp=1px. But it accepts decimal sizes, and it's somewhat problematic.
    // The size rounding is browser-dependent, so we do the decimal rounding for web by ourselves to have a
    // consistent behavior. We floor it, because it's better for the child to overlap by a pixel the right/bottom shadow part
    // than to have a pixel wide gap between them.
    if (isWeb)
        return Math.floor(value);
    return react_native_1.PixelRatio.roundToNearestPixel(value);
}
exports.R = R;
/** Converts dp to pixels. */
function P(value) {
    if (isWeb)
        return value;
    return react_native_1.PixelRatio.getPixelSizeForLayoutSize(value);
}
/** How many pixels for each dp. scale = pixels/dp */
const scale = isWeb ? 1 : react_native_1.PixelRatio.get();
/** Converts two sizes to pixel for perfect math, sum them and converts the result back to dp. */
function sumDps(a, b) {
    if (isWeb)
        return a + b;
    return R((P(a) + P(b)) / scale);
}
/** [Android/ios?] [*4] A small safe margin for the svg sizes.
 *
 * It fixes some gaps that we had, as even that the svg size and the svg rect for example size were the same, this rect
 * would still strangely be cropped/clipped. We give this additional size to the svg so our rect/etc won't be unintendedly clipped.
 *
 * It doesn't mean 1 pixel, as RN uses dp sizing, it's just an arbitrary and big enough number. */
const additional = isWeb ? 0 : 1;
const cornersArray = ['topLeft', 'topRight', 'bottomLeft', 'bottomRight'];
// const cornersShadowArray = ['topLeftShadow', 'topRightShadow', 'bottomLeftShadow', 'bottomRightShadow'] as const;
const sidesArray = ['left', 'right', 'top', 'bottom'];
const Shadow = ({ radius: radiusProp, sides: sidesProp = ['left', 'right', 'top', 'bottom'], corners: cornersProp = ['topLeft', 'topRight', 'bottomLeft', 'bottomRight'], containerViewStyle, startColor: startColorProp = '#00000020', finalColor: finalColorProp = '#0000', distance: distanceProp = 10, children, size: sizeProp, // Do not default here. We do `if (sizeProp)` on onLayout.
offset, getChildRadius = true, getViewStyleRadius = true, paintInside: paintInsideProp, viewStyle, safeRender = false, }) => {
    var _a, _b;
    const isRTL = react_native_1.I18nManager.isRTL;
    const [childWidth, setChildWidth] = react_1.useState();
    const [childHeight, setChildHeight] = react_1.useState();
    /** Defaults to true if offset is defined, else defaults to false */
    const paintInside = paintInsideProp !== null && paintInsideProp !== void 0 ? paintInsideProp : (offset ? true : false);
    const [offsetX, offsetY] = offset !== null && offset !== void 0 ? offset : [0, 0];
    const distance = R(Math.max(distanceProp, 0)); // Min val as 0
    /** Read {@link additional}, [*4] */
    const distanceWithAdditional = distance + additional;
    const width = (_a = (sizeProp ? R(sizeProp[0]) : childWidth)) !== null && _a !== void 0 ? _a : '100%'; // '100%' sometimes will lead to gaps. child size don't lie.
    const height = (_b = (sizeProp ? R(sizeProp[1]) : childHeight)) !== null && _b !== void 0 ? _b : '100%';
    /** Will (+ additional), only if its value isn't '100%'. */
    const widthWithAdditional = typeof width === 'string' ? width : width + additional;
    /** Will (+ additional), only if its value isn't '100%'. */
    const heightWithAdditional = typeof height === 'string' ? height : height + additional;
    const radii = react_1.useMemo(() => {
        /** Not yet treated. May be negative / undefined */
        const cornerRadiusPartial = (() => {
            var _a, _b;
            if (radiusProp !== undefined) {
                if (typeof radiusProp === 'number')
                    return utils_1.objFromKeys(cornersArray, () => radiusProp);
                else
                    return utils_1.objFromKeys(cornersArray, (k) => { var _a; return (_a = radiusProp[k]) !== null && _a !== void 0 ? _a : radiusProp.default; });
            }
            /** We have to merge both viewStyle and childStyle with care. A bottomLeftBorderRadius in childStyle for eg shall not replace
             * borderRadius in viewStyle.
             *
             * Props inits as undefined so in getChildRadius we can Object.values check for undefined. */
            // Map type to undefined union instead of Partial as Object.values don't treat optional as | undefined. Keeps this type-safe.
            let mergedStyle = { bottomLeft: undefined, bottomRight: undefined, topLeft: undefined, topRight: undefined };
            if (getViewStyleRadius) {
                const mergedViewStyle = react_native_1.StyleSheet.flatten(viewStyle !== null && viewStyle !== void 0 ? viewStyle : {}); // Convert possible array style to a single obj style.
                mergedStyle = utils_1.objFromKeys(cornersArray, (k) => { var _a, _b; return (_b = (_a = mergedViewStyle[utils_1.cornerToStyle(k, false)]) !== null && _a !== void 0 ? _a : mergedViewStyle[utils_1.cornerToStyle(k, true)]) !== null && _b !== void 0 ? _b : mergedViewStyle === null || mergedViewStyle === void 0 ? void 0 : mergedViewStyle.borderRadius; });
            }
            // Only enter block if there is a undefined corner that may now be defined;
            if (getChildRadius && Object.values(mergedStyle).includes(undefined)) {
                if (react_1.default.Children.count(children) > 1)
                    throw new Error('Only single child is accepted in Shadow component with getChildRadius={true} (default value). You should wrap it in a View or change this property to false and manually enter the borderRadius in the radius property.');
                /** May be an array of styles. */
                const childStyleTemp = ((_b = (_a = react_1.default.Children.only(children)) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.style);
                const childStyle = react_native_1.StyleSheet.flatten(childStyleTemp !== null && childStyleTemp !== void 0 ? childStyleTemp : {}); // Convert possible array style to a single obj style.
                mergedStyle = utils_1.objFromKeys(cornersArray, (k) => {
                    var _a, _b, _c;
                    return (_c = (_b = (_a = mergedStyle[k]) !== null && _a !== void 0 ? _a : childStyle[utils_1.cornerToStyle(k, false)]) !== null && _b !== void 0 ? _b : childStyle[utils_1.cornerToStyle(k, true)]) !== null && _c !== void 0 ? _c : childStyle === null || childStyle === void 0 ? void 0 : childStyle.borderRadius;
                });
            }
            return mergedStyle;
        })();
        /** Round and zero negative radius values */
        const radiiPreSizeLimit = utils_1.objFromKeys(cornersArray, (k) => { var _a; return R(Math.max((_a = cornerRadiusPartial[k]) !== null && _a !== void 0 ? _a : 0, 0)); });
        let result = radiiPreSizeLimit;
        if (typeof width === 'number' && typeof height === 'number') {
            // https://css-tricks.com/what-happens-when-border-radii-overlap/
            // Note that the tutorial doesn't mention the specification of minRatio < 1 but it's required as said on it and will malfunction without it.
            const minRatio = Math.min(// 'x / 0 = Infinity' is js, not a problem here.
            width / (radiiPreSizeLimit.topLeft + radiiPreSizeLimit.topRight), // top
            height / (radiiPreSizeLimit.topRight + radiiPreSizeLimit.bottomRight), // right
            width / (radiiPreSizeLimit.bottomLeft + radiiPreSizeLimit.bottomRight), // bottom
            height / (radiiPreSizeLimit.topLeft + radiiPreSizeLimit.bottomLeft));
            if (minRatio < 1)
                result = utils_1.objFromKeys(cornersArray, (k) => R(radiiPreSizeLimit[k] * minRatio));
        }
        return result;
    }, [children, getChildRadius, getViewStyleRadius, height, radiusProp, viewStyle, width]);
    const shadow = react_1.useMemo(() => {
        var _a, _b;
        // Skip if using safeRender and we still don't have the exact sizes, if we are still on the first render using the relative sizes.
        if (safeRender && (typeof width === 'string' || typeof height === 'string'))
            return null;
        // polished vs 'transparent': https://github.com/styled-components/polished/issues/566. Maybe tinycolor2 would allow it.
        const startColor = startColorProp === 'transparent' ? '#0000' : startColorProp;
        const finalColor = finalColorProp === 'transparent' ? '#0000' : finalColorProp;
        const startColorRgb = polished_1.parseToRgb(startColor);
        const finalColorRgb = polished_1.parseToRgb(finalColor);
        // [*1]: Seems that SVG in web accepts opacity in hex color, but in mobile doesn't.
        // So we remove the opacity from the color, and only apply the opacity in stopOpacity, so in web
        // it isn't applied twice.
        const startColorWoOpacity = polished_1.rgbToColorString(Object.assign(Object.assign({}, startColorRgb), { alpha: undefined })); // overwrite alpha
        const finalColorWoOpacity = polished_1.rgbToColorString(Object.assign(Object.assign({}, finalColorRgb), { alpha: undefined }));
        const startColorOpacity = (_a = startColorRgb.alpha) !== null && _a !== void 0 ? _a : 1;
        const finalColorOpacity = (_b = finalColorRgb.alpha) !== null && _b !== void 0 ? _b : 1;
        const { topLeft, topRight, bottomLeft, bottomRight } = radii;
        const cornerShadowRadius = {
            topLeftShadow: sumDps(topLeft, distance),
            topRightShadow: sumDps(topRight, distance),
            bottomLeftShadow: sumDps(bottomLeft, distance),
            bottomRightShadow: sumDps(bottomRight, distance),
        };
        const { topLeftShadow, topRightShadow, bottomLeftShadow, bottomRightShadow } = cornerShadowRadius;
        /** Which sides will have shadow. */
        const activeSides = utils_1.objFromKeys(sidesArray, (k) => sidesProp.includes(k));
        /** Which corners will have shadow. */
        const activeCorners = utils_1.objFromKeys(cornersArray, (k) => cornersProp.includes(k));
        // Fragment wasn't working for some reason, so, using array.
        const linearGradient = [
            // [*1] In mobile, it's required for the alpha to be set in opacity prop to work.
            // In web, smaller offsets needs to come before, so offset={0} definition comes first.
            react_1.default.createElement(react_native_svg_1.Stop, { offset: 0, stopColor: startColorWoOpacity, stopOpacity: startColorOpacity, key: '1' }),
            react_1.default.createElement(react_native_svg_1.Stop, { offset: 1, stopColor: finalColorWoOpacity, stopOpacity: finalColorOpacity, key: '2' }),
        ];
        function radialGradient(id, top, left, radius, shadowRadius) {
            return (react_1.default.createElement(react_native_svg_1.RadialGradient, { id: id, cx: left ? shadowRadius : 0, cy: top ? shadowRadius : 0, r: shadowRadius, gradientUnits: 'userSpaceOnUse' // won't show if this isn't set
             },
                react_1.default.createElement(react_native_svg_1.Stop, { offset: radius / shadowRadius, stopColor: startColorWoOpacity, stopOpacity: startColorOpacity }),
                react_1.default.createElement(react_native_svg_1.Stop, { offset: 1, stopColor: finalColorWoOpacity, stopOpacity: finalColorOpacity })));
        }
        return (react_1.default.createElement(react_1.default.Fragment, null,
            activeSides.left && react_1.default.createElement(react_native_svg_1.Svg, { width: distanceWithAdditional, height: heightWithAdditional, style: Object.assign({ position: 'absolute', left: -distance, top: topLeft }, (isRTL && { transform: [{ scaleX: -1 }] })) },
                react_1.default.createElement(react_native_svg_1.Defs, null,
                    react_1.default.createElement(react_native_svg_1.LinearGradient, { id: 'left', x1: '1', y1: '0', x2: '0', y2: '0' }, linearGradient)),
                react_1.default.createElement(react_native_svg_1.Rect, { width: distance, height: height, fill: 'url(#left)', y: -sumDps(topLeft, bottomLeft) })),
            activeSides.right && react_1.default.createElement(react_native_svg_1.Svg, { width: distanceWithAdditional, height: heightWithAdditional, style: Object.assign({ position: 'absolute', left: width, top: topRight }, (isRTL && { transform: [{ scaleX: -1 }] })) },
                react_1.default.createElement(react_native_svg_1.Defs, null,
                    react_1.default.createElement(react_native_svg_1.LinearGradient, { id: 'right', x1: '0', y1: '0', x2: '1', y2: '0' }, linearGradient)),
                react_1.default.createElement(react_native_svg_1.Rect, { width: distance, height: height, fill: 'url(#right)', y: -sumDps(topRight, bottomRight) })),
            activeSides.bottom && react_1.default.createElement(react_native_svg_1.Svg, { width: widthWithAdditional, height: distanceWithAdditional, style: Object.assign({ position: 'absolute', top: height, left: bottomLeft }, (isRTL && { transform: [{ scaleX: -1 }] })) },
                react_1.default.createElement(react_native_svg_1.Defs, null,
                    react_1.default.createElement(react_native_svg_1.LinearGradient, { id: 'bottom', x1: '0', y1: '0', x2: '0', y2: '1' }, linearGradient)),
                react_1.default.createElement(react_native_svg_1.Rect, { width: width, height: distance, fill: 'url(#bottom)', x: -sumDps(bottomLeft, bottomRight) })),
            activeSides.top && react_1.default.createElement(react_native_svg_1.Svg, { width: widthWithAdditional, height: distanceWithAdditional, style: Object.assign({ position: 'absolute', top: -distance, left: topLeft }, (isRTL && { transform: [{ scaleX: -1 }] })) },
                react_1.default.createElement(react_native_svg_1.Defs, null,
                    react_1.default.createElement(react_native_svg_1.LinearGradient, { id: 'top', x1: '0', y1: '1', x2: '0', y2: '0' }, linearGradient)),
                react_1.default.createElement(react_native_svg_1.Rect, { width: width, height: distance, fill: 'url(#top)', x: -sumDps(topLeft, topRight) })),
            activeCorners.topLeft && react_1.default.createElement(react_native_svg_1.Svg, { width: topLeftShadow + additional, height: topLeftShadow + additional, style: Object.assign({ position: 'absolute', top: -distance, left: -distance }, (isRTL && { transform: [{ scaleX: -1 }] })) },
                react_1.default.createElement(react_native_svg_1.Defs, null, radialGradient('topLeft', true, true, topLeft, topLeftShadow)),
                react_1.default.createElement(react_native_svg_1.Path, { fill: 'url(#topLeft)', d: `M0,${topLeftShadow} a${topLeftShadow},${topLeftShadow} 0 0 1 ${topLeftShadow} ${-topLeftShadow} v${distance} ${paintInside
                        ? `v${topLeft} h${-topLeft}` // read [*2] below for the explanation for this
                        : `a${topLeft},${topLeft} 0 0 0 ${-topLeft},${topLeft}`} h${-distance} Z` })),
            activeCorners.topRight && react_1.default.createElement(react_native_svg_1.Svg, { width: topRightShadow + additional, height: topRightShadow + additional, style: {
                    position: 'absolute', top: -distance, left: width,
                    transform: [{ translateX: isRTL ? bottomRight : -bottomRight }, ...(isRTL ? [{ scaleX: -1 }] : [])],
                } },
                react_1.default.createElement(react_native_svg_1.Defs, null, radialGradient('topRight', true, false, topRight, topRightShadow)),
                react_1.default.createElement(react_native_svg_1.Path, { fill: 'url(#topRight)', d: `M0,0 a${topRightShadow},${topRightShadow} 0 0 1 ${topRightShadow},${topRightShadow} h${-distance} ${paintInside
                        ? `h${-topRight} v${-topLeft}`
                        : `a${topRight},${topRight} 0 0 0 ${-topRight},${-topRight}`} v${-distance} Z` })),
            activeCorners.bottomLeft && react_1.default.createElement(react_native_svg_1.Svg, { width: bottomLeftShadow + additional, height: bottomLeftShadow + additional, style: { position: 'absolute', top: height, left: -distance, transform: [{ translateY: -bottomLeft }, ...(isRTL ? [{ scaleX: -1 }] : [])] } },
                react_1.default.createElement(react_native_svg_1.Defs, null, radialGradient('bottomLeft', false, true, bottomLeft, bottomLeftShadow)),
                react_1.default.createElement(react_native_svg_1.Path, { fill: 'url(#bottomLeft)', d: `M${bottomLeftShadow},${bottomLeftShadow} a${bottomLeftShadow},${bottomLeftShadow} 0 0 1 ${-bottomLeftShadow},${-bottomLeftShadow} h${distance} ${paintInside
                        ? `h${bottomLeft} v${bottomLeft}`
                        : `a${bottomLeft},${bottomLeft} 0 0 0 ${bottomLeft},${bottomLeft}`} v${distance} Z` })),
            activeCorners.bottomRight && react_1.default.createElement(react_native_svg_1.Svg, { width: bottomRightShadow + additional, height: bottomRightShadow + additional, style: {
                    position: 'absolute', top: height, left: width,
                    transform: [{ translateX: isRTL ? bottomRight : -bottomRight }, { translateY: -bottomRight }, ...(isRTL ? [{ scaleX: -1 }] : [])],
                } },
                react_1.default.createElement(react_native_svg_1.Defs, null, radialGradient('bottomRight', false, false, bottomRight, bottomRightShadow)),
                react_1.default.createElement(react_native_svg_1.Path, { fill: 'url(#bottomRight)', d: `M${bottomRightShadow},0 a${bottomRightShadow},${bottomRightShadow} 0 0 1 ${-bottomRightShadow},${bottomRightShadow} v${-distance} ${paintInside
                        ? `v${-bottomRight} h${bottomRight}`
                        : `a${bottomRight},${bottomRight} 0 0 0 ${bottomRight},${-bottomRight}`} h${distance} Z` })),
            paintInside && react_1.default.createElement(react_native_svg_1.Svg, { width: widthWithAdditional, height: heightWithAdditional, style: Object.assign({ position: 'absolute' }, (isRTL && { transform: [{ scaleX: -1 }] })) },
                react_1.default.createElement(react_native_svg_1.Defs, null,
                    react_1.default.createElement(react_native_svg_1.Mask, { id: 'maskPaintBelow' },
                        react_1.default.createElement(react_native_svg_1.Rect, { width: width, height: height, fill: '#fff' }),
                        react_1.default.createElement(react_native_svg_1.Rect, { width: topLeft, height: topLeft, fill: '#000' }),
                        react_1.default.createElement(react_native_svg_1.Rect, { width: topRight, height: topRight, x: width, transform: `translate(${-topRight}, 0)`, fill: '#000' }),
                        react_1.default.createElement(react_native_svg_1.Rect, { width: bottomLeft, height: bottomLeft, y: height, transform: `translate(0, ${-bottomLeft})`, fill: '#000' }),
                        react_1.default.createElement(react_native_svg_1.Rect, { width: bottomRight, height: bottomRight, x: width, y: height, transform: `translate(${-bottomRight}, ${-bottomRight})`, fill: '#000' }))),
                react_1.default.createElement(react_native_svg_1.Rect, { width: width, height: height, mask: 'url(#maskPaintBelow)', fill: startColorWoOpacity, fillOpacity: startColorOpacity }))));
    }, [
        safeRender, width, height, startColorProp, finalColorProp, radii, distance, distanceWithAdditional, heightWithAdditional,
        widthWithAdditional, paintInside, sidesProp, cornersProp, isRTL,
    ]);
    const result = react_1.useMemo(() => {
        return (
        // pointerEvents: https://github.com/SrBrahma/react-native-shadow-2/issues/24
        react_1.default.createElement(react_native_1.View, { style: [containerViewStyle], pointerEvents: 'box-none' },
            react_1.default.createElement(react_native_1.View, { style: { width: '100%', height: '100%', position: 'absolute', left: offsetX, top: offsetY } }, shadow),
            react_1.default.createElement(react_native_1.View, { pointerEvents: "box-none", style: [
                    // Without alignSelf: 'flex-start', if your Shadow component had a sibling under the same View, the shadow would try to have the same size of the sibling,
                    // being it for example a text below the shadowed component. https://imgur.com/a/V6ZV0lI, https://github.com/SrBrahma/react-native-shadow-2/issues/7#issuecomment-899764882
                    { alignSelf: 'flex-start' },
                    sizeProp && {
                        width, height,
                        borderTopLeftRadius: radii.topLeft,
                        borderTopRightRadius: radii.topRight,
                        borderBottomLeftRadius: radii.bottomLeft,
                        borderBottomRightRadius: radii.bottomRight,
                    }, viewStyle,
                ], onLayout: (e) => {
                    if (sizeProp) // For some really strange reason, attaching conditionally the onLayout wasn't working
                        return; // on condition change, so we check here inside if the sizeProp is defined.
                    // [web] [*3]: the width/height we get here is already rounded by RN, even if the real size according to the browser
                    // inspector is decimal. It will round up if (>= .5), else, down.
                    const layout = e.nativeEvent.layout;
                    setChildWidth(layout.width); // In web to round decimal values to integers. In mobile it's already rounded.
                    setChildHeight(layout.height);
                } }, children)));
    }, [shadow, children, width, height, sizeProp, radii, viewStyle, containerViewStyle, offsetX, offsetY]);
    return result;
};
exports.Shadow = Shadow;
