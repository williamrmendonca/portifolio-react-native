import React from 'react';
import { StyleProp, ViewStyle } from 'react-native';
/** Rounds the given size to a pixel perfect size. */
export declare function R(value: number): number;
export interface ShadowProps {
    /** The color of the shadow when it's right next to the given content, leaving it.
     * Accepts alpha channel.
     *
     * @default '#00000020' */
    startColor?: string;
    /** The color of the shadow at the maximum distance from the content. Accepts alpha channel.
     * @default '#0000', transparent. */
    finalColor?: string;
    /** How far the shadow will go.
     * @default 10 */
    distance?: number;
    /** The radius of each corner of your child component. Passing a number will apply it to all corners.
     *
     * If passing an object, undefined corners will have the radius of the `default` property if it's defined.
     *
     * If undefined and if getChildRadius, it will attempt to get the child radius from the borderRadius style.
     *
     * Each corner fallbacks to 0. */
    radius?: number | {
        default?: number;
        topLeft?: number;
        topRight?: number;
        bottomLeft?: number;
        bottomRight?: number;
    };
    /** If it should try to get the radius from the child view **`style`** if `radius` property is undefined. It will get the values for each
     * corner, like `borderTopLeftRadius`, and also `borderRadius`. If a specific corner isn't defined, `borderRadius` value is used.
     *
     * If **`getViewStyleRadius`**, the corners defined in viewStyle will have priority over child's style.
     *
     * @default true */
    getChildRadius?: boolean;
    /** If it should try to get the radius from the **`viewStyle`** property if `radius` property is undefined. It will get the values for each
     * corner, like `borderTopLeftRadius`, and also `borderRadius`. If a specific corner isn't defined, `borderRadius` value is used.
     *
     * If **`getChildRadius`**, the corners defined in viewStyle will have priority over child's style.
     * @default true */
    getViewStyleRadius?: boolean;
    /** The sides of your content that will have the shadows drawn. Doesn't include corners.
     *
     * @default ['left', 'right', 'top', 'bottom'] */
    sides?: ('left' | 'right' | 'top' | 'bottom')[];
    /** The corners that will have the shadows drawn.
     *
     * @default ['topLeft', 'topRight', 'bottomLeft', 'bottomRight'] */
    corners?: ('topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight')[];
    /** Moves the shadow. Negative x moves it to the left, negative y moves it up.
     *
     * Accepts `'x%'` values, in relation to the child's size.
     *
     * Setting an offset will default `paintInside` to true, as it is the usual desired behaviour.
     *
     * @default [0, 0] */
    offset?: [x: number | string, y: number | string];
    /** If the shadow should be applied inside the external shadows, below the child. `startColor` is used as fill color.
     *
     * You may want this as true when using offset or if your child have some transparency.
     *
     * **The default changes to true if `offset` property is defined.**
     *
     * @default false */
    paintInside?: boolean;
    /** The style of the view that wraps your child component.
     *
     * If using the `size` property, this wrapping view will automatically receive as style the `size` values and the
     * radiuses from the `radius` property or from the child, if `getChildRadius`. You may overwrite those defaults
     * by undefine'ing the changed styles in this property. */
    viewStyle?: StyleProp<ViewStyle>;
    /** The style of the view that contains the shadow and your child component. */
    containerViewStyle?: StyleProp<ViewStyle>;
    /** If it should try to get the `width` and `height` from the child **style** if `size` prop is undefined.
     *
     * If the size style is found, it won't use the onLayout strategy to get the child style after its render.
     * @default true */
    /** If you don't want the 2 renders of the shadow (first applies the relative positioning and sizing that may contain a quick pixel gap, second uses exact pixel size from onLayout) or you are having noticeable gaps/overlaps on the first render,
     * you can use this property. Using this won't trigger the onLayout, so only 1 render is made.
     *
     * It will apply the corresponding `width` and `height` styles to the `viewStyle` property.
     *
     * You may want to set `backgroundColor` in the `viewStyle` property for your child background color.
     *
     * It's also good if you want an animated view.
     *
     * The values will be properly rounded using our R() function. */
    size?: [width: number, height: number];
    /** If you don't want the relative sizing and positioning of the shadow on the first render, but only on the second render and
     * beyond with the exact onLayout sizes. This is useful if dealing with radius greater than the sizes, to assure
     * the fully round corners when the sides sizes are unknown and to avoid weird and overflowing shadows on the first render.
     *
     * Note that when true, the shadow will only appear on the second render and beyond, when the sizes are known with onLayout.
     *
     * @default false */
    safeRender?: boolean;
}
export declare const Shadow: React.FC<ShadowProps>;
