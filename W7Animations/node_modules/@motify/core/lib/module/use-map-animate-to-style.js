import { usePresence } from 'framer-motion';
import { useCallback, useEffect } from 'react';
import { useAnimatedStyle, useSharedValue, withDecay, withSpring, withTiming, withDelay, withRepeat, withSequence, runOnJS } from 'react-native-reanimated';
import { PackageName } from './constants/package-name';

const debug = (...args) => {
  'worklet';

  if (args) {// hi
  } // console.log('[moti]', ...args)

};

const isColor = styleKey => {
  'worklet';

  return ['backgroundColor', 'borderBottomColor', 'borderColor', 'borderEndColor', 'borderLeftColor', 'borderRightColor', 'borderStartColor', 'borderTopColor', 'color'].includes(styleKey);
};

const isTransform = styleKey => {
  'worklet';

  const transforms = ['perspective', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'translateX', 'translateY', 'skewX', 'skewY'];
  return transforms.includes(styleKey);
};

function animationDelay(key, transition, defaultDelay) {
  'worklet';

  var _ref;

  let delayMs = defaultDelay;

  if ((transition === null || transition === void 0 ? void 0 : (_ref = transition[key]) === null || _ref === void 0 ? void 0 : _ref.delay) != null) {
    var _ref2;

    delayMs = transition === null || transition === void 0 ? void 0 : (_ref2 = transition[key]) === null || _ref2 === void 0 ? void 0 : _ref2.delay;
  } else if ((transition === null || transition === void 0 ? void 0 : transition.delay) != null) {
    delayMs = transition.delay;
  }

  return {
    delayMs
  };
}

function animationConfig(styleProp, transition) {
  'worklet';

  var _ref3, _loop, _ref4, _ref5, _ref7;

  const key = styleProp;
  let repeatCount = 0;
  let repeatReverse = true;
  let animationType = 'spring';
  if (isColor(key) || key === 'opacity') animationType = 'timing'; // say that we're looking at `width`
  // first, check if we have transition.width.type

  if (transition !== null && transition !== void 0 && (_ref3 = transition[key]) !== null && _ref3 !== void 0 && _ref3.type) {
    var _key;

    animationType = (_key = transition[key]) === null || _key === void 0 ? void 0 : _key.type;
  } else if (transition !== null && transition !== void 0 && transition.type) {
    // otherwise, fallback to transition.type
    animationType = transition.type;
  }

  const loop = (_loop = transition === null || transition === void 0 ? void 0 : (_ref4 = transition[key]) === null || _ref4 === void 0 ? void 0 : _ref4.loop) !== null && _loop !== void 0 ? _loop : transition === null || transition === void 0 ? void 0 : transition.loop;

  if (loop != null) {
    repeatCount = loop ? -1 : 0;
  }

  if ((transition === null || transition === void 0 ? void 0 : (_ref5 = transition[key]) === null || _ref5 === void 0 ? void 0 : _ref5.repeat) != null) {
    var _ref6;

    repeatCount = transition === null || transition === void 0 ? void 0 : (_ref6 = transition[key]) === null || _ref6 === void 0 ? void 0 : _ref6.repeat;
  } else if ((transition === null || transition === void 0 ? void 0 : transition.repeat) != null) {
    repeatCount = transition.repeat;
  }

  if ((transition === null || transition === void 0 ? void 0 : (_ref7 = transition[key]) === null || _ref7 === void 0 ? void 0 : _ref7.repeatReverse) != null) {
    var _ref8;

    repeatReverse = transition === null || transition === void 0 ? void 0 : (_ref8 = transition[key]) === null || _ref8 === void 0 ? void 0 : _ref8.repeatReverse;
  } else if ((transition === null || transition === void 0 ? void 0 : transition.repeatReverse) != null) {
    repeatReverse = transition.repeatReverse;
  }

  debug({
    loop,
    key,
    repeatCount,
    animationType
  });
  let config = {}; // so sad, but fix it later :(

  let animation = (...props) => props;

  if (animationType === 'timing') {
    var _duration, _ref9, _easing, _ref10;

    const duration = (_duration = transition === null || transition === void 0 ? void 0 : (_ref9 = transition[key]) === null || _ref9 === void 0 ? void 0 : _ref9.duration) !== null && _duration !== void 0 ? _duration : transition === null || transition === void 0 ? void 0 : transition.duration;
    const easing = (_easing = transition === null || transition === void 0 ? void 0 : (_ref10 = transition[key]) === null || _ref10 === void 0 ? void 0 : _ref10.easing) !== null && _easing !== void 0 ? _easing : transition === null || transition === void 0 ? void 0 : transition.easing;

    if (easing) {
      config['easing'] = easing;
    }

    if (duration != null) {
      config['duration'] = duration;
    }

    animation = withTiming;
  } else if (animationType === 'spring') {
    animation = withSpring;
    config = {// solve the missing velocity bug in 2.0.0-rc.0
      // velocity: 2,
    };
    const configKeys = ['damping', 'mass', 'overshootClamping', 'restDisplacementThreshold', 'restSpeedThreshold', 'stiffness', 'velocity'];
    configKeys.forEach(configKey => {
      'worklet';

      var _transition$key;

      const styleSpecificConfig = transition === null || transition === void 0 ? void 0 : (_transition$key = transition[key]) === null || _transition$key === void 0 ? void 0 : _transition$key[configKey];
      const transitionConfigForKey = transition === null || transition === void 0 ? void 0 : transition[configKey];

      if (styleSpecificConfig != null) {
        config[configKey] = styleSpecificConfig;
      } else if (transitionConfigForKey != null) {
        config[configKey] = transitionConfigForKey;
      }
    });
  } else if (animationType === 'decay') {
    // TODO decay doesn't work for now
    console.error("[".concat(PackageName, "]: You passed transition type: decay, but this isn't working for now. Honestly, not sure why yet. Try passing other transition fields, like clamp, velocity, and deceleration. If that solves it, please open an issue and let me know."));
    animation = withDecay;
    config = {
      velocity: 2,
      deceleration: 2
    };
    const configKeys = ['clamp', 'velocity', 'deceleration'];
    configKeys.forEach(configKey => {
      'worklet'; // is this necessary ^ don't think so...?

      var _transition$key2;

      const styleSpecificConfig = transition === null || transition === void 0 ? void 0 : (_transition$key2 = transition[key]) === null || _transition$key2 === void 0 ? void 0 : _transition$key2[configKey];
      const transitionConfigForKey = transition === null || transition === void 0 ? void 0 : transition[configKey];

      if (styleSpecificConfig != null) {
        config[configKey] = styleSpecificConfig;
      } else if (transitionConfigForKey != null) {
        config[configKey] = transitionConfigForKey;
      }
    });
  }

  return {
    animation,
    config,
    repeatReverse,
    repeatCount,
    shouldRepeat: !!repeatCount
  };
}

export default function useMapAnimateToStyle({
  animate,
  from = false,
  transition: transitionProp,
  delay: defaultDelay,
  state,
  stylePriority = 'animate',
  onDidAnimate,
  exit,
  animateInitialState = false,
  exitTransition
}) {
  const isMounted = useSharedValue(false);
  const [isPresent, safeToUnmount] = usePresence();
  const reanimatedSafeToUnmount = useCallback(() => {
    safeToUnmount === null || safeToUnmount === void 0 ? void 0 : safeToUnmount();
  }, [safeToUnmount]);
  const reanimatedOnDidAnimated = useCallback((...args) => {
    onDidAnimate === null || onDidAnimate === void 0 ? void 0 : onDidAnimate(...args);
  }, [onDidAnimate]);
  const hasExitStyle = typeof exit === 'object' && !!Object.keys(exit !== null && exit !== void 0 ? exit : {}).length;
  const style = useAnimatedStyle(() => {
    var _state$__state;

    const final = {
      // initializing here fixes reanimated object.__defineProperty bug(?)
      transform: []
    };
    const variantStyle = (state === null || state === void 0 ? void 0 : (_state$__state = state.__state) === null || _state$__state === void 0 ? void 0 : _state$__state.value) || {};
    const animateStyle = animate || {};
    const initialStyle = from || {};
    const exitStyle = exit || {};
    const isExiting = !isPresent && hasExitStyle;
    let mergedStyles = {};

    if (stylePriority === 'state') {
      mergedStyles = Object.assign({}, animateStyle, variantStyle);
    } else {
      mergedStyles = Object.assign({}, variantStyle, animateStyle);
    }

    if (isExiting && exitStyle) {
      mergedStyles = Object.assign({}, exitStyle);
    }

    debug('here'); // reduce doesn't work with spreads/reanimated Objects!
    // const exitingStyleProps: Record<string, boolean> = Object.keys(
    //   mergedStyles || {}
    // ).reduce((obj, styleKey) => ({ ...obj, [styleKey]: true }), {})
    // use forEach instead!

    const exitingStyleProps = {};
    Object.keys(exitStyle || {}).forEach(key => {
      exitingStyleProps[key] = true;
    });
    let transition = transitionProp;

    if (isExiting && exitTransition) {
      transition = Object.assign({}, transition, exitTransition);
    }

    Object.keys(mergedStyles).forEach(key => {
      const initialValue = initialStyle[key];
      const value = mergedStyles[key];
      const {
        animation,
        config,
        shouldRepeat,
        repeatCount,
        repeatReverse
      } = animationConfig(key, transition);

      const callback = (completed, recentValue) => {
        if (onDidAnimate) {
          runOnJS(reanimatedOnDidAnimated)(key, completed, recentValue, {
            attempedValue: value
          });
        }

        if (isExiting) {
          exitingStyleProps[key] = false;
          const areStylesExiting = Object.values(exitingStyleProps).some(Boolean); // if this is true, then we've finished our exit animations

          if (!areStylesExiting) {
            runOnJS(reanimatedSafeToUnmount)();
          }
        }
      };

      if (initialValue != null) {
        // if we haven't mounted, or if there's no other value to use besides the initial one, use it.
        if (isMounted.value === false || value == null) {
          if (isTransform(key) && final.transform) {
            const transform = {};

            if (isMounted.value || animateInitialState) {
              transform[key] = animation(initialValue, config);
            } else {
              transform[key] = initialValue;
            } // final.transform.push({ [key]: initialValue }) does not work!


            final.transform.push(transform);
          } else {
            if (isMounted.value || animateInitialState) {
              final[key] = animation(initialValue, config);
            } else {
              final[key] = initialValue;
            }
          }

          return;
        }
      }

      let {
        delayMs
      } = animationDelay(key, transition, defaultDelay);

      if (isColor(key)) {
        // TODO: FIX THIS
        // if (__DEV__) {
        if (typeof value === 'string' && !value.startsWith('rgb') && !value.startsWith('#')) {
          console.error("[".concat(PackageName, "]: You passed ").concat(key, ": ").concat(value, ", but not all color values are supported yet in Reanimated 2. \u2639\uFE0F\n\n      Please use an rgb or hex formatted color."));
        } // }

      }

      if (value == null || value === false) {
        // skip missing values
        // this is useful if you want to do {opacity: loading && 1}
        // without this, those values will break I think
        return;
      }

      if (Array.isArray(value)) {
        // we have a sequence

        /**
         * There is some code duplication in this section and in the ones below.
         *
         * However, I prefer this for open source. It makes it easier for collaborators to identify issues without a million wrappers.
         *
         * If there's something *obvious* that would benefit from abstraction, we can. But let's keep it simple.
         */
        const sequence = value.filter(step => {
          // remove null, false values to allow for conditional styles
          if (typeof step === 'object') {
            return (step === null || step === void 0 ? void 0 : step.value) != null && (step === null || step === void 0 ? void 0 : step.value) !== false;
          }

          return step != null && step !== false;
        }).map(step => {
          let stepDelay = delayMs;
          let stepValue = step;
          let stepConfig = Object.assign({}, config);
          let stepAnimation = animation;

          if (typeof step === 'object') {
            // not allowed in Reanimated: { delay, value, ...transition } = step
            const transition = Object.assign({}, step);
            delete transition.delay;
            delete transition.value;
            const {
              config: inlineStepConfig,
              animation
            } = animationConfig(key, transition);
            stepConfig = Object.assign({}, stepConfig, inlineStepConfig);
            stepAnimation = animation;

            if (step.delay != null) {
              stepDelay = step.delay;
            }

            stepValue = step.value;
          }

          const sequenceValue = stepAnimation(stepValue, stepConfig, callback);

          if (stepDelay != null) {
            return withDelay(stepDelay, sequenceValue);
          }

          return sequenceValue;
        }).filter(Boolean);

        if (isTransform(key)) {
          // we have a sequence of transforms
          final['transform'] = final['transform'] || [];

          if (sequence.length) {
            const transform = {};
            transform[key] = withSequence(sequence[0], ...sequence.slice(1)); // @ts-ignore

            final['transform'].push(transform);
          }
        } else {
          // we have a normal sequence of items
          // shadows not supported
          if (sequence.length) {
            final[key] = withSequence(sequence[0], ...sequence.slice(1));
          }
        }
      } else if (isTransform(key)) {
        var _transition, _transition$key3;

        final['transform'] = final['transform'] || []; // const transformKey = Object.keys(transformProp)[0]
        // const transformValue = transformProp[transformKey]

        if (((_transition = transition) === null || _transition === void 0 ? void 0 : (_transition$key3 = _transition[key]) === null || _transition$key3 === void 0 ? void 0 : _transition$key3.delay) != null) {
          var _transition2, _transition2$key;

          delayMs = (_transition2 = transition) === null || _transition2 === void 0 ? void 0 : (_transition2$key = _transition2[key]) === null || _transition2$key === void 0 ? void 0 : _transition2$key.delay;
        }

        const transform = {};
        let finalValue = animation(value, config, callback);

        if (shouldRepeat) {
          finalValue = withRepeat(finalValue, repeatCount, repeatReverse);
        }

        if (delayMs != null) {
          transform[key] = withDelay(delayMs, finalValue);
        } else {
          transform[key] = finalValue;
        } // @ts-ignore


        final['transform'].push(transform);
      } else if (typeof value === 'object') {
        // shadows
        final[key] = {};
        Object.keys(value || {}).forEach(innerStyleKey => {
          let finalValue = animation(value, config, callback);

          if (shouldRepeat) {
            finalValue = withRepeat(finalValue, repeatCount, repeatReverse);
          }

          if (delayMs != null) {
            final[key][innerStyleKey] = withDelay(delayMs, finalValue);
          } else {
            final[key][innerStyleKey] = finalValue;
          }
        });
      } else {
        let finalValue = animation(value, config, callback);

        if (shouldRepeat) {
          finalValue = withRepeat(finalValue, repeatCount, repeatReverse);
        }

        if (delayMs != null && typeof delayMs === 'number') {
          final[key] = withDelay(delayMs, finalValue);
        } else {
          final[key] = finalValue;
        }
      }
    }); // TODO
    // if (!final.transform?.length) {
    //   delete final.transform
    // }

    return final;
  });
  useEffect(() => {
    isMounted.value = true;
  }, [isMounted]);
  useEffect(function allowUnMountIfMissingExit() {
    if (!isPresent && !hasExitStyle) {
      safeToUnmount === null || safeToUnmount === void 0 ? void 0 : safeToUnmount();
    }
  }, [hasExitStyle, isPresent, safeToUnmount]);
  return {
    style
  };
}
//# sourceMappingURL=use-map-animate-to-style.js.map